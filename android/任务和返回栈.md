任务(Task)是指在执行特定作业时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈（即*返回栈*）中。

Activity 和任务的默认行为总结如下：

* 当 Activity A 启动 Activity B 时，Activity A 将会停止，但系统会保留其状态（例如，滚动位置和已输入表单中的文本）。如果用户在处于 Activity B 时按*“返回”*按钮，则 Activity A 将恢复其状态，继续执行。
* 用户通过按*“主页”*按钮离开任务时，当前 Activity 将停止且其任务会进入后台。 系统将保留任务中每个 Activity 的状态。如果用户稍后通过选择开始任务的启动器图标来恢复任务，则任务将出现在前台并恢复执行堆栈顶部的 Activity。
* 如果用户按*“返回”*按钮，则当前 Activity 会从堆栈弹出并被销毁。 堆栈中的前一个 Activity 恢复执行。销毁 Activity 时，系统*不会*保留该 Activity 的状态。
* 即使来自其他任务，Activity 也可以多次实例化。

### 保存Activity状态

当 Activity 停止时，系统的默认行为会保留其状态。 这样一来，当用户导航回到上一个 Activity 时，其用户界面与用户离开时一样。 但是，在 Activity 被销毁且必须重建时，您可以而且**应当**主动使用回调方法保留 Activity 的状态。

 为了避免用户的工作丢失，您应主动通过在 Activity 中实现 `onSaveInstanceState()` 回调方法来保留工作。

### 管理任务

通过使用 [`activity`](https://developer.android.google.cn/guide/topics/manifest/activity-element.html?hl=zh-cn)清单文件元素中的属性和传递给 `startActivity()` 的 Intent 中的标志，可以管理任务和返回栈的行为。

#### 定义启动模式

启动模式允许您定义 Activity 的新实例如何与当前任务关联。 您可以通过两种方法定义不同的启动模式：

* 使用清单文件

  在清单文件中声明 Activity 时，您可以指定 Activity 在启动时应该如何与任务关联。

* 使用Intent标志

  调用 `startActivity()` 时，可以在 `Intent` 中加入一个标志，用于声明新 Activity 如何（或是否）与当前任务关联。

如果 Activity A 启动 Activity B，则 Activity B 可以在其清单文件中定义它应该如何与当前任务关联（如果可能），并且 Activity A 还可以请求 Activity B 应该如何与当前任务关联。如果这两个 Activity 均定义 Activity B 应该如何与任务关联，则 Activity A 的请求（如 Intent 中所定义）优先级要高于 Activity B 的请求（如其清单文件中所定义）

#### 使用清单文件

在清单文件中声明 Activity 时，您可以使用 [``](https://developer.android.google.cn/guide/topics/manifest/activity-element.html?hl=zh-cn) 元素的 [`launchMode`](https://developer.android.google.cn/guide/topics/manifest/activity-element.html?hl=zh-cn#lmode) 属性指定 Activity 应该如何与任务关联。

[`launchMode`](https://developer.android.google.cn/guide/topics/manifest/activity-element.html?hl=zh-cn#lmode) 属性指定有关应如何将 Activity 启动到任务中的指令。您可以分配给 `launchMode` 属性的启动模式共有四种：

* `"standard"`（默认模式）

  默认。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。

* `"singleTop"`

  如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 `onNewIntent()` 方法向其传送 Intent，而不是创建 Activity 的新实例。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的 Activity 并不是 Activity 的现有实例）。

  **注**：为某个 Activity 创建新实例时，用户可以按*“返回”*按钮返回到前一个 Activity。 但是，当 Activity 的现有实例处理新 Intent 时，则在新 Intent 到达 `onNewIntent()` 之前，用户无法按*“返回”*按钮返回到 Activity 的状态。

* `"singleTask"`

  系统创建新任务并实例化位于新任务底部的 Activity。但是，如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的`onNewIntent()` 方法向其传送 Intent，而不是创建新实例。一次只能存在 Activity 的一个实例。

  **注**：尽管 Activity 在新任务中启动，但是用户按*“返回”*按钮仍会返回到前一个 Activity。

* `"singleInstance"`

  与 "singleTask" 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。

显示如何将启动模式为“singleTask”的 Activity 添加到返回栈。 如果 Activity 已经是某个拥有自己的返回栈的后台任务的一部分，则整个返回栈也会上移到当前任务的顶部。

![singleTask](https://developer.android.google.cn/images/fundamentals/diagram_backstack_singletask_multiactivity.png?hl=zh-cn)

#### 使用Intent标志

启动 Activity 时，您可以通过在传递给 `startActivity()` 的 Intent 中加入相应的标志，修改 Activity 与其任务的默认关联方式。可用于修改默认行为的标志包括：

* `FLAG_ACTIVITY_NEW_TASK`

  在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 `onNewIntent()` 中收到新 Intent。正如前文所述，这会产生与 `"singleTask"`[`launchMode`](https://developer.android.google.cn/guide/topics/manifest/activity-element.html?hl=zh-cn#lmode) 值相同的行为。

* `FLAG_ACTIVITY_SINGLE_TOP`

  如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 `onNewIntent()` 的调用，而不是创建 Activity 的新实例。正如前文所述，这会产生与 `"singleTop"`[`launchMode`](https://developer.android.google.cn/guide/topics/manifest/activity-element.html?hl=zh-cn#lmode) 值相同的行为。

* `FLAG_ACTIVITY_CLEAR_TOP`

  与`FLAG_ACTIVITY_SINGLE_TOP`结合使用，如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 `onNewIntent()` 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。

  产生这种行为的 [`launchMode`](https://developer.android.google.cn/guide/topics/manifest/activity-element.html?hl=zh-cn#lmode) 属性没有值。

  `FLAG_ACTIVITY_CLEAR_TOP` 通常与 `FLAG_ACTIVITY_NEW_TASK` 结合使用。一起使用时，通过这些标志，可以找到其他任务中的现有 Activity，并将其放入可从中响应 Intent 的位置。(会重新生成新的实例)

  **注**：如果指定 Activity 的启动模式为 `"standard"`，则该 Activity 也会从堆栈中移除，并在其位置启动一个新实例，以便处理传入的 Intent。 这是因为当启动模式为 `"standard"` 时，将始终为新 Intent 创建新实例。

* `FLAG_ACTIVITY_CLEAR_TASK`

  ​