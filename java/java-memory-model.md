## Java 内存模型

java内存模型在JVM中划分为 **Thread Stack（堆栈）**和 **Head(堆)**。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png)

运行在 JVM 中每个线程都拥有各自的堆栈。堆栈中包含**有关线程调用以到达当前执行点的方法的信息(调用栈)**。当线程执行到它的代码时候，调用栈改变。

堆栈还包含每个正在执行方法的所有**局部变量**，每个线程只能访问各自的堆栈。就算有两个线程执行同样的代码，也都会在各自的堆栈上生成各自的局部变量。

所有**基本类型的局部变量**都完全储存在堆栈中。一个线程可以将一个原始变量的副本传递给另一个线程，但是它不能共享原语局部变量本身。

堆中存储着当前应用，无论哪个线程创建的**所有对象**，这里对象包括，基本类型的包装类。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png)

一个使用基本类型的局部变量，那它将完全被储存在堆栈上。

一个引用的局部变量，那这个引用本身是储存在堆栈上，被引用的对象则储存在堆上。

一个对象可能包含方法，且这些方法包含着局部变量，则这些局部变量则储存在堆栈上，即使这个方法所属的对象储存在堆上。

一个对象的**成员变量**和**对象本身**都存储在堆上，即使这个成员变量是基本类型或者是引用类型。

**静态类变量**也与类定义一起存储在堆上。

在堆上的对象可以被所有线程访问

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png)

## 硬件内存架构

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png)

一个现代计算机总是拥有两个或者更多的 CPU，而这些 CPU 也可能拥有多个核心。每个 CPU 能够在任何给定时间运行一个线程。这意味着如果你的Java应用程序是多线程的，每个 CPU 的线程可能在 Java 应用程序中同时（同时）运行。

每个 CPU 包含一组寄存器，这些寄存器本质上是 CPU 内存，CPU 对这些寄存器的访问要比主内存**（Main Memory）**要快得多。

每个CPU都可能拥有 CPU 缓存，CPU 对 CPU 缓存的访问要比主内存要快，但慢于寄存器。

每个CPU都包含主内存**（RAM，随机存取储存器）**，主内存要比 CPU 缓存大的多。

通常，当 CPU 需要访问主存储器时，它将把主存储器的一部分读取到其 CPU 高速缓存中。它甚至可以将高速缓存的一部分读取到其内部寄存器中，然后对其执行操作。

当 CPU 需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时间将值刷新回主存储器。

通常，CPU 缓存使用**缓存行（cache lines）**为单位，来进行数据的操作。

## 硬件内存架构和Java内存模型之间的联系

硬件内存架构不区分线程堆栈和堆。在硬件上，线程堆栈和堆都位于主存储器中。线程堆栈和堆的部分有时可能存在于 CPU 高速缓存和内部 CPU 寄存器中。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png)

当对象和变量可以存储在计算机中的各种不同的存储器区域中时(同时计算机存在多个CPU)，可能发生某些问题。两个主要问题是：

* 线程更新（写入）共享变量的可见性。
* 读取，检查和写入共享变量时的竞争关系


## 共享对象的可见性

当两个或更多的线程共享一个对象时，而没有使用 `valatile` 或者 `synchronization`，在其中一个线程上更新了对象，可能对其他线程是不可见的操作。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png)

解决这个问题，你可以使用 Java 的 `valatile`，它会**保证变量直接从主内存中读取和更新时写回主内存**。

## 竞争关系

如果两个或者更多的线程共享一个对象，有超过一个线程去更新这个共享对象，就有可能发生**竞争关系**。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png)

解决这个问题，可以使用 **Java synochronized Block(Java同步代码块)** 。它可以**保证在任何给定时间只有一个线程可以进入代码的给定临界段，和访问的所有变量都将从主内存中读取，并且当线程退出时，所有更新都将再次刷新回主内存，不管这个变量有没有被声明为 `valatile` **。

