## Java内存模型

java内存模型在JVM中划分为**Thread Stack(堆栈)**和**Head(堆)**。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png)

运行在JVM中每个线程都拥有各自的堆栈。堆栈中包含**有关线程调用以到达当前执行点的方法的信息(调用栈)**。当线程执行到它的代码时候，调用栈改变。

堆栈还包含每个正在执行方法的所有局部变量，每个线程只能访问各自的堆栈。就算有两个线程执行同样的代码，也都会在各自的堆栈上生成各自的局部变量。

所有基本类型的局部变量都完全储存在堆栈中。一个线程可以将一个原始变量的副本传递给另一个线程，但是它不能共享原语局部变量本身。

堆中存储着当前应用，无论哪个线程创建的所有对象，这里对象包括，基本类型的包装类。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png)

一个使用基本类型的局部变量，那它将完全被储存在堆栈上。

一个引用的局部变量，那这个引用本身是储存在堆栈上，被引用的对象则储存在堆上。

一个对象可能包含方法，且这些方法包含着局部变量，则这些局部变量则储存在堆栈上，即使这个方法所属的对象储存在堆上。

一个对象的成员变量和对象本身都存储在堆上，即使这个成员变量是基本类型或者是引用类型。

静态类变量也与类定义一起存储在堆上。

在堆上的对象可以被所有线程访问

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png)

## 硬件内存架构

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png)

一个现代计算机总是拥有两个或者更多的CPU，而这些CPU也可能拥有多个核心。每个CPU能够在任何给定时间运行一个线程。这意味着如果你的Java应用程序是多线程的，每个CPU的一个线程可能在Java应用程序中同时（同时）运行。

每个CPU包含一组寄存器，这些寄存器本质上是CPU内存，CPU对这些寄存器的访问要比主内存**(Main Memory)**要快得多。

每个CPU都可能拥有CPU缓存，CPU对CPU缓存的访问要比主内存要快，但慢于寄存器。

每个CPU都包含主内存(**RAM**)，主内存要比CPU缓存大的多。

通常，当CPU需要访问主存储器时，它将把主存储器的一部分读取到其CPU高速缓存中。它甚至可以将高速缓存的一部分读取到其内部寄存器中，然后对其执行操作。

当CPU需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时间将值刷新回主存储器。

通常，CPU缓存使用**缓存行(cache lines)**为单位，来进行数据的操作。

## 硬件内存架构和Java内存模型之间的联系

硬件内存架构不区分线程堆栈和堆。在硬件上，线程堆栈和堆都位于主存储器中。线程堆栈和堆的部分有时可能存在于CPU高速缓存和内部CPU寄存器中。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png)

当对象和变量可以存储在计算机中的各种不同的存储器区域中时(同时计算机存在多个CPU)，可能发生某些问题。两个主要问题是：

* 线程更新（写入）共享变量的可见性。
* 读取，检查和写入共享变量时的竞争关系


## 共享对象的可见性

当两个或更多的线程共享一个对象时，而没有使用`valatile`或者`synchronization`，在其中一个线程上更新了对象，可能对其他线程是不可见的操作。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png)

解决这个问题，你可以使用Java的`valatile`，它会**保证变量直接从主内存中读取和更新时写回主内存**。

## 竞争关系

如果两个或者更多的线程共享一个对象，有超过一个线程去更新这个共享对象，就有可能发生**竞争关系**。

![图片](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png)

解决这个问题，可以使用**Java synochronized Block(Java同步代码块)**。它可以**保证在任何给定时间只有一个线程可以进入代码的给定临界段，和访问的所有变量都将从主内存中读取，并且当线程退出时，所有更新都将再次刷新回主内存，不管这个变量有没有被声明为`valatile`**。

## Java内存模型和并发编程

* 原子性

在Java中，对基本数据类型变量的读取和赋值是原子性操作，即这些操作是不可被中断的。

```java
x = 10;//原子性
y = x;//非原子性
x++;//非原子性
x = x + 1;//非原子性
```

不过有一点需要注意的是：在32位平台下，对64位数据的读取和赋值都是需要两个操作来完成的，不能保证其原子性。

* 可见性

对于可见性，Java提供了`valatile`关键字来保证可见性。

* 有序性

在Java内存模型中，允许编译器和处理器对指令进行重排序，这个过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

在Java里面，可以通过`valatile`关键字来保证一定的"有序性"，也可以通过`synchronized`和`Lock`来保证有序性，但**Java内存模型具备一些先天的有序性，即不需要通过任何手段就能保证的有序性，这个也称为happens-before原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证它们的有序性**。

happens-before(先行发生原则)

* 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
* 锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作
* volatile变量规则：对一个**volatile修饰的**变量的写操作先行发生于后面对这个变量的读操作
* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
* 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
* 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

对于第一条来说，虽然虚拟机可能进行指令重排序，但它只会对不存在数据依赖的指令进行重排，在单个线程中，最后的执行结果看起来就是有序执行的，注意:**这个规则智能保证在单个线程执行结果的正确性，无法保证程序在多线程中执行结果的正确性**。

