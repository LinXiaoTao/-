Java1.5发行版中增加了两个新的引用类型家族：枚举(enum type)和注解类型(annotation type)。

* 第三十条：用enum代替int常量

  枚举类型(enum type)是指由一组固定的常量组成合法值的类型。在编程语言引入枚举类型之前，表示枚举类型的常用模式是声明一组具名的int常量：

  ``` java
  public static final int APPLE = 0;
  public static final int ORANCE = 1;
  ```

  这种方法称作**int枚举模式**，存在诸多不足，它在类型安全性和使用方便性方面没有任何帮助。同样的，使用String常量的称为**String枚举模式**。

  从Java1.5开始，就提出另外一种可以替代的解决方案，这就是**enum枚举类型**。

  ``` java
  public enum Apple{
    FUJI,PIPPIN;
  }
  ```

  Java枚举通过公有的静态final域为每个枚举常量导出实例的类，因为没有可以访问的构造器，枚举类型是真正的final。枚举类型是实例受控的。

  1. 枚举提供了编译时的类型安全
  2. 包含同名常量的多个枚举类型可以在一个系统中和平共处，因为每个类型都有自己的命名空间。
  3. 可以增加或者重新排列枚举类型的常量，而无需重新编译它的客户端代码，因为导出常量的域在枚举类型和它的客户端之间提供了一个隔离层：常量值并没有被编译到客户端代码中，而是在int枚举模式之中。
  4. 可以调用toString方法，将枚举转换成可打印的字符串。
  5. 允许添加任意的方法和域，并实现任意的接口，提供了所有的Object方法的高级实现，实现了Comparable和Serializable接口，并针对枚举类型的可任意改变性设计了序列化方式。

  可以通过增加适当的方法来增强枚举类型。

  为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存到域中的构造器。枚举天生不可变，因此所有的域都**应该(非必需)**为final的。

  有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象方法。这种方法被称为**特定于常量的方法实现**。

  **使用特定于常量的方法实现**有一个美中不足的地方，它们使得在枚举常量中共享代码变得更加困难了。但你想要实现每当添加一个枚举常量时，就强制选择一种应用策略，可以使用**策略枚举**的方法。

  枚举中的switch语句适用于给外部的枚举类型增加特定于常量的行为，比如某个枚举不受你的控制，而你希望有个实例方法来返回某些枚举常量的特定行为。

  与int常量相比，枚举有个小小的性能缺点，即装载和初始化枚举时会有空间和时间的成本。

  枚举要易读得多，也更加安全，功能更加强大。许多枚举都不需要显式的构造器或者成员，但有枚举受益于**每个常量与属性的关联**以及**提供行为受这个属性影响的方法**。只有少数的枚举类型受益于将多种行为与单个方法关联，在这种情况下，特定于常量的方法要优于启用自有值的枚举。如果多个枚举常量同时共享相同的行为，则考虑策略枚举。

* 第三十一条：用实例域替代序数

  永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。

* 第三十二条：用EnumSet代替位域

  如果一个枚举类型的元素主要用在集合中，一般就使用int枚举模式，将2的不同倍数赋予每个常量：

  ``` java
  public static final int STYLE_BOLD = 1 << 0;
  public static final int STYLE_ITAIC = 1 << 1;
  public static final int STYLE_UNDERLINE = 1 << 2;
  ```

  这种表示法让你用OR位运算符将几个常量合并到一个集合中，称为**位域**。

  ``` java
  public void applyStyle(int style){
   
  }

  applyStyle(STYLE_BOLD | STYLE_ITAIC);
  ```

  位域表示法也允许使用位操作，有效地执行像union(联合)和intersection(交集)这样的集合操作。

  java.util包提供了EnumSet类来有效地表示从单个枚举类型中提取的多个值的多个集合。在内部具体的实现上，每个EnumSet内容都表示为位矢量。如果底层的枚举类型有64个或者更少的元素，整个EnumSet就是用单个long来表示。

  正是因为枚举类型要用在集合中，所以没有理由用位域来表示它。

* 第三十三条：用EnumMap代替序数索引

  EnumMap在内部使用数组，但是对外隐藏实现细节，集Map的丰富功能和类型安全与数组的快速，注意EnumMap构造器采用键类型的Class对象，这是一个有限制的类型令牌，它提供了运行时泛型信息。

  最好不要用序数来索引数组，而要使用EnumMap。

* 第三十四条：用接口模拟可伸缩的枚举

  操作码(opcode)指：它的元素表示在某种机器上的那些操作的枚举类型。

  有一种很好的方法可以利用枚举类型来实现这种效果，由于枚举类型可以通过给操作码类型和(属于接口的标准实现的)枚举定义接口，来实现任何接口。虽然枚举类型是不可扩展的，但接口类型是可扩展。

  总而言之，虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。