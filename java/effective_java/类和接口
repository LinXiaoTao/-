1.第十三条:使类和成员的可访问性最小
设计良好的模块会隐藏所有的实现细节，把它的API和实现清晰地隔离开来。然后，模块之间只通过它们的API进行通信，以达到"信息隐藏"或封装。
a.尽可能地使每个类或者成员不被外界访问
b.实例域决不能是公有的

2.第十四条:在公有类中使用访问方法而非公有域
应该使用包含私有域和公有访问方法(get,set)

3.第十五条:使可变性最小化
为了使类成为不可变，要遵循下面五条规则:
(1)不要提供任何会修改对象状态的方法
(2)保证类不会被扩展
(3)使所有的域都是final的
(4)使所有的域都成为私有的
(5)确保对于任何可变组件的互斥访问
不可变对象的优点:
(1)不可变对象比较简单
(2)不可变对象本质上是线程安全的
(3)不仅可以共享不可变对象，甚至也可以共享它们的内部信息
(4)不可变对象为其他对象提供了大量的构件
不可变对象真正唯一的缺点是"对于每个不同的值都需要一个单独的对象"
除非有令人信服的理由要使域成为是非final的，否则要使每个域都是final的

4.第十六条:复合优先于继承
继承违背了封装原则，只有当子类和超类之间确实存在子类型关系使，使用继承才是恰当的。即便如此，如果子类和超类处于不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性。
不用扩展现有的类，而是在新的类中增加一个似有域，它引用现有类中的一个实例。这种设计被称做"复合"，因为现有的类变成了新类中的一个组件。新类中的每个实例方法都可以调用被包含的现有类是实例中对应的方法，并返回它的结果。这被称为"转发"，新类中的方法被称为"转发方法"。

5.第十七条:要么为继承而设计，并提供文档说明，要么就禁止继承
该类必须有文档说明它可覆盖的方法的自用性。
类必须通过某种形式提供适当的钩子（hook），以便能够进入到它的内部工作流程中，这种形式可以是精心选择的受保护（protected）的方法，也可以是受保护的域。
对于为了继承而设计的类，唯一的测试方法就是编写子类，经验表明，三个子类通常足以测试一个可扩展的类
构造器绝不能调用可被覆盖的方法。无论是clone还是readObject，都不可以调用可覆盖的方法，不管是直接还是间接的方式。
