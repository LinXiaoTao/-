* 第三十八条：检查参数的有效性

  绝大多数的方法和构造器对于传递给它们的参数值都会有某些限制，如果传递无效的参数值给方法，这个方法在执行之前先对参数进行了检查，那么它很快就会失败，并且清楚地出现适当的异常。对于公有方法，要用javadoc的`@throws`标签在文档中说明违反参数值限制时会抛出的异常。对于未被导出的方法，通常应该使用**断言**来检查它们的参数，具体做法如下所示：

  ``` java
  private static void sort(long a[],int offset,int length){
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
  }
  ```

  从本质上讲，这些断言是在声称被断言的条件将会为真，无论外围包的客户端如何使用它。不同于一般的有效性检查，断言如果失败，将会抛出AssertionError。如果它们没有起到作用，本质上也不会有成本开销。

  在方法执行它的计算任务之前，应该先检查它的参数，但有例外，如果有效性检查工作非常昂贵或者不切实际。

  简而言之，每当编写方法或者构造器时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式检查来实施这些限制。

* 第三十九条：必要时进行保护性拷贝

  对于构造器的每个可变参数进行保护性拷贝是必要的。

  注意：保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。这样做可以避免在“危险阶段”期间从另外一个线程改变类的参数，这里的“危险阶段”是指从检查参数开始，直到拷贝参数之间的时间段。(在计算机安全社区中，这被称为**Time-Of-Check/Time-Of-Use或者TOCTOU攻击**)。

  对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。

  使访问方法返回可变内部域的保护性拷贝。

  总而言之，如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来替代保护性拷贝。

* 第四十条：谨慎设计方法签名

  1. 谨慎地选择方法的名称。
  2. 不要过于追求提供便利的方法。
  3. 避免过长的参数列表。有三种方法可以缩短过长的参数列表。第一种是把方法分解为多个方法。第二种是创建辅助类，用来保存参数的分组。第三种是，从对象构建到方法调用都采用Builder模式。
  4. 对于参数类型，要优先使用接口而不是类。
  5. 对于boolean参数，要优先使用两个元素的枚举类型。

* 第四十一条：慎用重载

  调用哪个重载方法( overloading method )是在编译时做出决定的。

  ``` java
  public static String classify(List<?> list){
    return "List";
  }
  public static String classify(Set<?> s){
    return "Set";
  }
  public static String classify(Collection<?> c){
    return "Unknown Collection";
  }
  public static void main(String[] args){
    Collection<?>[] collections = {new HashSet<String>(),new ArrayList<String>(),new HashMap<String,String>().values()};
    for(Collection<?> c : collections)
      System.out.println(classify(c));
  }
  ```

  对于上面的例子，会输出三次 "Unknown Collection" 。因为对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。选择被覆盖的方法是在运行时决定的。

  > 注：这个静态选择是根据编译时的引用类型，例如上面的例子，如果用 `List list = new ArrayList<String>()` 去调用 `classify` ，那么会输出 `List` 。

  因为覆盖机制时规范的，而重载机制是例外，所以应该**避免胡乱地使用重载机制**。

  安全而保守的策略时，永远不要导出两个相同类型参数的重载方法。如果方法使用可变参数，保守的策略时根本不要重载它。

  简而言之，**能够重载方法**并不意味着就**应该重载方法**。一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。

* 第四十二条：慎用可变参数

  Java 1.5 发行版增加了可变参数 (varargs) 方法，一般称作 variable arity method (可匹配不同长度变量的方法)。可变参数方法可以接受 0 个或者多个指定类型的参数。可变参数机制通过先创建一个数组，数组的大小为调用位置所传递的参数数量，然后将参数值传到数组中，最后将数组传递给方法。