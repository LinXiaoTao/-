* 第三十八条：检查参数的有效性

  绝大多数的方法和构造器对于传递给它们的参数值都会有某些限制，如果传递无效的参数值给方法，这个方法在执行之前先对参数进行了检查，那么它很快就会失败，并且清楚地出现适当的异常。对于公有方法，要用javadoc的`@throws`标签在文档中说明违反参数值限制时会抛出的异常。对于未被导出的方法，通常应该使用**断言**来检查它们的参数，具体做法如下所示：

  ``` java
  private static void sort(long a[],int offset,int length){
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
  }
  ```

  从本质上讲，这些断言是在声称被断言的条件将会为真，无论外围包的客户端如何使用它。不同于一般的有效性检查，断言如果失败，将会抛出AssertionError。如果它们没有起到作用，本质上也不会有成本开销。

  在方法执行它的计算任务之前，应该先检查它的参数，但有例外，如果有效性检查工作非常昂贵或者不切实际。

  简而言之，每当编写方法或者构造器时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式检查来实施这些限制。

* 第三十九条：必要时进行保护性拷贝

  对于构造器的每个可变参数进行保护性拷贝是必要的。

  注意：保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。这样做可以避免在“危险阶段”期间从另外一个线程改变类的参数，这里的“危险阶段”是指从检查参数开始，直到拷贝参数之间的时间段。(在计算机安全社区中，这被称为**Time-Of-Check/Time-Of-Use或者TOCTOU攻击**)。

  对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。

  使访问方法返回可变内部域的保护性拷贝。

  总而言之，如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来替代保护性拷贝。

* 第四十条：谨慎设计方法签名

  1. 谨慎地选择方法的名称。
  2. 不要过于追求提供便利的方法。
  3. 避免过长的参数列表。有三种方法可以缩短过长的参数列表。第一种是把方法分解为多个方法。第二种是创建辅助类，用来保存参数的分组。第三种是，从对象构建到方法调用都采用Builder模式。
  4. 对于参数类型，要优先使用接口而不是类。
  5. 对于boolean参数，要优先使用两个元素的枚举类型。

* 第四十一条：慎用重载

  ​