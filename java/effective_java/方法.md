* 第三十八条：检查参数的有效性

  绝大多数的方法和构造器对于传递给它们的参数值都会有某些限制，如果传递无效的参数值给方法，这个方法在执行之前先对参数进行了检查，那么它很快就会失败，并且清楚地出现适当的异常。对于公有方法，要用javadoc的`@throws`标签在文档中说明违反参数值限制时会抛出的异常。对于未被导出的方法，通常应该使用**断言**来检查它们的参数，具体做法如下所示：

  ``` java
  private static void sort(long a[],int offset,int length){
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
  }
  ```

  从本质上讲，这些断言是在声称被断言的条件将会为真，无论外围包的客户端如何使用它。不同于一般的有效性检查，断言如果失败，将会抛出AssertionError。如果它们没有起到作用，本质上也不会有成本开销。

  在方法执行它的计算任务之前，应该先检查它的参数，但有例外，如果有效性检查工作非常昂贵或者不切实际。

  简而言之，每当编写方法或者构造器时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式检查来实施这些限制。

* 第三十九条：必要时进行保护性拷贝

  对于构造器的每个可变参数进行保护性拷贝是必要的。

  注意：保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。这样做可以避免在“危险阶段”期间从另外一个线程改变类的参数，这里的“危险阶段”是指从检查参数开始，直到拷贝参数之间的时间段。(在计算机安全社区中，这被称为**Time-Of-Check/Time-Of-Use或者TOCTOU攻击**)。

  对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。

  使访问方法返回可变内部域的保护性拷贝。

  总而言之，如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来替代保护性拷贝。

* 第四十条：谨慎设计方法签名

  1. 谨慎地选择方法的名称。
  2. 不要过于追求提供便利的方法。
  3. 避免过长的参数列表。有三种方法可以缩短过长的参数列表。第一种是把方法分解为多个方法。第二种是创建辅助类，用来保存参数的分组。第三种是，从对象构建到方法调用都采用Builder模式。
  4. 对于参数类型，要优先使用接口而不是类。
  5. 对于boolean参数，要优先使用两个元素的枚举类型。

* 第四十一条：慎用重载

  调用哪个重载方法( overloading method )是在编译时做出决定的。

  ``` java
  public static String classify(List<?> list){
    return "List";
  }
  public static String classify(Set<?> s){
    return "Set";
  }
  public static String classify(Collection<?> c){
    return "Unknown Collection";
  }
  public static void main(String[] args){
    Collection<?>[] collections = {new HashSet<String>(),new ArrayList<String>(),new HashMap<String,String>().values()};
    for(Collection<?> c : collections)
      System.out.println(classify(c));
  }
  ```

  对于上面的例子，会输出三次 "Unknown Collection" 。因为对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。选择被覆盖的方法是在运行时决定的。

  > 注：这个静态选择是根据编译时的引用类型，例如上面的例子，如果用 `List list = new ArrayList<String>()` 去调用 `classify` ，那么会输出 `List` 。

  因为覆盖机制时规范的，而重载机制是例外，所以应该**避免胡乱地使用重载机制**。

  安全而保守的策略时，永远不要导出两个相同类型参数的重载方法。如果方法使用可变参数，保守的策略时根本不要重载它。

  简而言之，**能够重载方法**并不意味着就**应该重载方法**。一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。

* 第四十二条：慎用可变参数

  Java 1.5 发行版增加了可变参数 (varargs) 方法，一般称作 variable arity method (可匹配不同长度变量的方法)。可变参数方法可以接受 0 个或者多个指定类型的参数。可变参数机制通过先创建一个数组，数组的大小为调用位置所传递的参数数量，然后将参数值传到数组中，最后将数组传递给方法。

  不必改造具有 final 数组参数的每个方法；只当确实是在数量不定的值上执行调用时才使用可变参数。

  在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。

  简而言之，在定义参数数目不定的方法，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。

* 第四十三条：返回零长度的数组或者集合，而不是 null

  简而言之，返回类型为数组或集合的方法没理由返回 null，而不是返回一个零长度的数组或者集合。

* 第四十四条：为所有导出的 API 元素编写文档注释

  Java 环境提供了一种被称为 Javadoc 的实用工具，利用特殊格式的文档注释，通常被写作 doc comment ，根据源代码自动产生 API 文档。

  为了正确地编写 API 文档，必须在每个被导出的类，接口，构造器，方法和域声明之前增加一个文档注释。

  方法的文档注释应该简洁地描述出它和客户端之间的约定。这个约定应该说明这个方法做了什么，而不是说明它是如何完成这项工作的。文档注释应该列举出这个方法的前提条件 (**procondition**) 和后置条件 (**postcondition**)，所谓前提条件是指为了使客户能够调用这个方法，而必须要满足的条件；所谓后置条件是指在调用成功完成之后，哪些条件必须要满足。

  每个方法应该在文档中描述它的副作用 (**side effect**)。所谓副作用是指系统状态中可以观察到的变化，它不是为了获得后置条件而明确要求的变化。

  文档注释也应该描述类或者方法的**线程安全性 (thrad safety**)。

  为了完整地描述方法的约定，方法的文档注释应该让每个参数都有一个 `@param` 标签，以及一个 `@return` 标签(除非这个方法的返回类型为 `void` )，以及对于该方法抛出的每个异常，无论是受检的还是未受检的，都有一个 `@thraws` 标签。按惯例，跟在 `@param` 标签或者 `@return` 标签后面的文字应该是一个名词短语，描述了这个参数或者返回值所表示的值。跟在 `@throws` 标签之后的文字应该包含单词 **if** (如果)，紧接着是一个名词短语，它描述了这个异常将在什么样的条件下会被抛出。有时候，也会用算术表达式来代替名词短语。按惯例，`@param`、`@return` 或者 `@throws` 标签后面的短语或者字句都不用句点来结束。

  Javadoc{@code} 标签更好，因为它避免了转义 HTML 元字符。在多行的代码示例前使用字符 `<pre>{@code`，然后在代码后面加上 `}</pre`。

  最后，要注意这个文档注释中用到了单词 `this` 。按惯例，当 `this` 被用在实例方法的文档注释中时，它应该始终是指方法调用所在的对象。

  为了产生 HTML 元字符的文档，比如小于号 (<)，大于号 (>) 以及 "与"号 (&)，要用 `{@literal`} 标签将它们包围起来。

  文档注释在源代码和产生的文档中都应该是易于阅读的。如果无法让两者都易读，产生的文档的可读性要优于源代码的可读性。

  每个文档注释的第一句话成了该注释所属元素的 **概要描述 (summary description) **。为了避免混淆，同一个类或者接口中的两个成员或者构造器，不应该具有同样的概要描述。

  当为泛型或者方法编写文档时，确保要在文档中说明所有的类型参数。

  当为枚举类型编写文档时，要确保在文档中说明常量，以及类型，还有任何公有的方法。

  为注解类型编写文档时，要确保在文档中说明所有成员，以及类型本身。

  Javadoc 具有 **继承** 方法注释的能力。如果 API 元素没有文档注释，Javadoc 将会搜索最为适用的文档注释，接口的文档注释优于超类的文档注释。也可以利用 `@inheritDoc` 标签从超类型中继承文档注释的部分内容。

  使用 HTML有效性检查器 (HTML validity checker) 来运行由 javadoc 产生的 HTML 文件。

  简而言之，要为 API 编写文档，文档注释是最好的、最有效的途径。对于所有可导出的 API 元素来说，使用文档注释应该被看作是强制性的。要采用一致的风格来遵循标准的约定。记住，在文档注释内部出现任何 HTML 标签都是允许的，但是 HTML 元字符必须要经过转义。

