* ### 第十三条:使类和成员的可访问性最小

设计良好的模块会隐藏所有的实现细节，把它的API和实现清晰地隔离开来。然后，模块之间只通过它们的API进行通信，以达到"信息隐藏"或封装。

1. 尽可能地使每个类或者成员不被外界访问
2. 实例域决不能是公有的

* ### 第十四条:在公有类中使用访问方法而非公有域

应该使用包含私有域和公有访问方法(get,set)

* ### 第十五条:使可变性最小化

为了使类成为不可变，要遵循下面五条规则:

1. 不要提供任何会修改对象状态的方法
2. 保证类不会被扩展
3. 使所有的域都是final的
4. 使所有的域都成为私有的
5. 确保对于任何可变组件的互斥访问

不可变对象的优点:

1. 不可变对象比较简单
2. 不可变对象本质上是线程安全的
3. 不仅可以共享不可变对象，甚至也可以共享它们的内部信息
4. 不可变对象为其他对象提供了大量的构件

不可变对象真正唯一的缺点是"对于每个不同的值都需要一个单独的对象"
除非有令人信服的理由要使域成为是非final的，否则要使每个域都是final的

* ### 第十六条:复合优先于继承

继承违背了封装原则，只有当子类和超类之间确实存在子类型关系使，使用继承才是恰当的。即便如此，如果子类和超类处于不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性。

不用扩展现有的类，而是在新的类中增加一个似有域，它引用现有类中的一个实例。这种设计被称做"复合"，因为现有的类变成了新类中的一个组件。新类中的每个实例方法都可以调用被包含的现有类是实例中对应的方法，并返回它的结果。这被称为"转发"，新类中的方法被称为"转发方法"。

* ### 第十七条:要么为继承而设计，并提供文档说明，要么就禁止继承

该类必须有文档说明它可覆盖的方法的自用性。

类必须通过某种形式提供适当的钩子（hook），以便能够进入到它的内部工作流程中，这种形式可以是精心选择的受保护（protected）的方法，也可以是受保护的域。

对于为了继承而设计的类，唯一的测试方法就是编写子类，经验表明，三个子类通常足以测试一个可扩展的类

构造器绝不能调用可被覆盖的方法。无论是clone还是readObject，都不可以调用可覆盖的方法，不管是直接还是间接的方式。

* ### 第十八条:接口优于抽象类

接口相对于抽象类而言有如下好处:

1. 现有的类可以容易被更新，以实现新的接口。
2. 接口是定义mixin(混合类型)的理想选择
3. 接口允许我们构造非层次结构的类型选择

**通过对你导出的每个重要接口都提供一个抽象的骨架实现(skeletal implementation)类，把接口和抽象类的优点结合起来。**

骨架实现的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加"抽象类被用作类型定义时"所持有的严格限制。此外，骨架实现仍然能够有助于接口的实现。实现了这个接口可以把对于接口方法的调用，转发到一个内部私有类的实例上，这种方法被称作**模拟多称继承**。

骨架实现有**简单实现(simple implementation)**，它就像个骨架实现，这是因为它实现了接口，并且是为了继承设计的，但是区别在于它不是抽象的，你是最简单的可能的有效实现，你可以原封不动的使用，也可以将它子类化。

使用抽象类相对接口有个明显的优势:**抽象类的演变比接口的演变要容易多了**。

设计公有的接口要非常谨慎。**接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。**

* ### 第十九条:接口只用于定义类型

当类实现接口时，接口就充当可以引用这个类的实例的类型(**type**)。因此，类实现了接口，就表明客户端可以对这个类的实例实施某些动作，为了任何其他目的而定义接口是不恰当的。

**常量接口模式是接口的不良使用**。这种接口没有包含任何方法，它只包含静态的final域。

```java
public interface InterfaceB {
     String HELLO_WORLD = "hello_world";
}
```

类在使用某些常量，这纯粹是实现细节，实现常量接口，会导致把这样的实现细节泄露到该类的导出API。类实现常量接口，这对于这个类的用户来说，完全没有什么价值。

* ### 第二十条:类层次优于标签类

```java
public class LabelTest {
    enum TAG {ONE, TWO}

    final TAG mTag;
    String mOneName;
    int mTwoName;

    public LabelTest(String oneName) {
        mTag = TAG.ONE;
        mOneName = oneName;
    }

    public LabelTest(int twoName) {
        mTag = TAG.TWO;
        mTwoName = twoName;
    }

    public void show() {
        switch (mTag) {
            case ONE:
                System.out.println(mOneName);
                break;
            case TWO:
                System.out.println(String.valueOf(mTwoName));
                break;
        }
    }
}
```

这种**标签类**有着许多缺点，充斥着大量样本代码，包括枚举，标签域，以及条件语句，破坏了可读性。内存占用增加，因为实例承担着属于其他风格的不相干的域，域不能被final，除非在构造方法中初始化了不相干的域。**标签类过于冗长，容易出错，并且效率低下**。

更多的实现类的多种风格的方式是**类层次**。

```java
public abstract class BaseLabel {
    abstract void show();
}
public class OneLabel extends BaseLabel {
    final String mOneName;


    public OneLabel(String oneName) {
        mOneName = oneName;
    }

    @Override
    void show() {
        System.out.println(mOneName);
    }
}
public class TwoLabel extends BaseLabel {

    int mTwoName;

    public TwoLabel(int twoName) {
        mTwoName = twoName;
    }

    @Override
    void show() {
        System.out.println(String.valueOf(mTwoName));
    }
}

```

类层次纠正了标签类所有的缺点，简单清楚，没有包含样板代码，每个类的实现都配有自己的类，没有受到其他不相干域的影响，可以定义为final。

类层次的另外个好处在于，它们可以用来反映类型之间本质上的层次关系。

* ### 第二十一条:用函数对象表示策略

有些语言支持**函数指针，代理，lambda表达式**或者其他类似的机制，允许程序把"调用特殊函数的能力"储存起来并传递这种能力。这种机制通常用于允许函数的调用者通过传入第二个函数，来制定自己的行为(**策略模式**)。

为了在java 中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。当被用来重复使用时，它的类通常就要被实现为私有的静态成员类，并通过公有的静态final域被导出来，其类型为该策略接口。

* ### 第二十二条:优先考虑静态成员类

**嵌套类**是指被定义在另外一个类的内部的类。有四种:

1. 静态成员类
2. 非静态成员类
3. 匿名类
4. 局部类

除了第一个之外，其他三种都被称为**内部类**。非静态成员类都每个实例都隐含着与外围类的一个**外围实例(enclosing instance)**。**如果声明成员不要求访问外围类，就要始终把static修饰符放在它的声明上**。