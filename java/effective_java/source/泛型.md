Java1.5发行版中增加了**泛型(Generic)**。

声明中具有一个或者多个**类型参数(type parameter)**的类或者接口，就是泛型类或者接口。

每种泛型定义一组**参数化的类型(parameterized type)**。

每个泛型都定义一个**原生态类型(raw type)**，即不带任何实际类型参数的泛型名称。例如:List<String>对应的原生态类型是List。

* 第二十三条:请不要在新代码中使用原生态类型

如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。

如果要使用泛型，但不确定或者不关心实际的类型参数，就可以使用一个问号代替，称为**无限制的通配符类型(unbounded wildcard type)**。

通配符是安全的，原生态类型是不安全，可以将任何元素放进是使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件，但**不能将任何元素(除了null)放到Collection<?>中**。

这条规则有两个小小的例外，两者都源于**泛型信息可以在运行时被擦除**。

1. 在类文字(class literal)中必须使用原生态类型。例如List.claa，String[].class和int.class都合法，但是List<String>.class和List<?>.class则是不合法。
2. 在参数化类型而非无限制通配符类型上使用`instanceof`是非法的，用无限制通配符代替原生态类型，对`instanceof`操作符的行为不会产生任何影响。尖括号(<>)和问号(?)显得多余了。使用泛型来使用`instanceof`的首选方法:

```java
if(o instanceof Set){
  Set<?> m = (Set<?>) o;
}
```

一旦确定这个o是个Set，就必须将它转换成通配符类型Set<?>，而不是原生态类型Set，这是个受检查的转换，因此不会导致任何警告。

* 第二十四条:消除非受检警告

如果无法消除警告，同时可以证明引起警告的代码是类型安全的，才可以用一个``@SuppressWarnings("unchecked")``注解来禁止这条警告。

应该尽可能小的范围中使用`SuppressWarnings`注解。

每当使用`suppressWarnings`注解时，都要添加一条注释，说明为什么这么做是安全的。

* 第二十五条:列表优先于数组

数组和泛型相比，有两个重要的不同点。

1. 数组是**协变的(covariant)**，表示如果Sub是Super的子类型，那么数组类型Sub[]就是Super[]的子类型。相反，泛型则是**不可变的(invariant)**。
2. 数组时**具体化的(reified)**，因此数组会在运行时才知道并检查它们的元素类型约束。相比之下，泛型则是通过**擦除(erasure)**来实现的，因此泛型只在编译时强化它们的类型信息，并在运行时丢弃(或者擦除)它们的元素类型信息。

由于上述这些根本的区别，因此数组和泛型不能很好的混合使用。例如，创建泛型、参数化类型或者类型参数的数组是非法的。

``` java
//new List<E>[]
//new List<String>[]
//new E[]
```

