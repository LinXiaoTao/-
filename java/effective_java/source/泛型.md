Java1.5发行版中增加了**泛型(Generic)**。

声明中具有一个或者多个**类型参数(type parameter)**的类或者接口，就是泛型类或者接口。

每种泛型定义一组**参数化的类型(parameterized type)**。

每个泛型都定义一个**原生态类型(raw type)**，即不带任何实际类型参数的泛型名称。例如:List<String>对应的原生态类型是List。

* 第二十三条:请不要在新代码中使用原生态类型

如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。

如果要使用泛型，但不确定或者不关心实际的类型参数，就可以使用一个问号代替，称为**无限制的通配符类型(unbounded wildcard type)**。

通配符是安全的，原生态类型是不安全，可以将任何元素放进是使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件，但**不能将任何元素(除了null)放到Collection<?>中**。

这条规则有两个小小的例外，两者都源于**泛型信息可以在运行时被擦除**。

1. 在类文字(class literal)中必须使用原生态类型。例如List.claa，String[].class和int.class都合法，但是List<String>.class和List<?>.class则是不合法。
2. 在参数化类型而非无限制通配符类型上使用`instanceof`是非法的，用无限制通配符代替原生态类型，对`instanceof`操作符的行为不会产生任何影响。尖括号(<>)和问号(?)显得多余了。使用泛型来使用`instanceof`的首选方法:

```java
if(o instanceof Set){
  Set<?> m = (Set<?>) o;
}
```

一旦确定这个o是个Set，就必须将它转换成通配符类型Set<?>，而不是原生态类型Set，这是个受检查的转换，因此不会导致任何警告。

* 第二十四条:消除非受检警告

如果无法消除警告，同时可以证明引起警告的代码是类型安全的，才可以用一个``@SuppressWarnings("unchecked")``注解来禁止这条警告。